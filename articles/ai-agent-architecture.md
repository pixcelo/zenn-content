---
title: "AIエージェント設計の3つのアプローチ：プレイブック・MCP・ハイブリッド型の選択指針"
emoji: "🤖"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["ai", "architecture", "mcp", "aiエージェント", "llm"]
published: false
publication_name: "nexta_" # 企業のPublication名を指定
---

新人エンジニアにタスクを任せるとき、詳細な手順書を渡しますか？それとも目標だけ伝えて任せますか？経験豊富な開発者なら、この判断が後のプロジェクト成否を左右することを知っています。

AIエージェントでも、まったく同じ判断が求められています。エージェントに**厳格な手順を守らせるか**、それとも**目標達成の方法を自由に考えさせるか**——この設計選択が、システムの信頼性、開発効率、そして事業リスクを決定します。

現在、この課題に対して3つの主要なアーキテクチャアプローチがあります：

- **プレイブック駆動型**：確実な手順を事前定義し、エージェントはその案内役に徹する「**制御重視**」
- **[MCP（Model Context Protocol）](https://spec.modelcontextprotocol.io/)対応型**：エージェント自身に判断を委ね、状況に応じて最適解を模索させる「**自律重視**」
- **ハイブリッド型**：上記2つの利点を統合し、実用性を追求する「**統合重視**」

本記事では、これら3つのアプローチを技術的な観点だけでなく、ビジネスリスク・開発コスト・保守性まで含めて比較分析します。あなたのプロジェクトに最適な選択を支援する、実践的な判断基準を提供します。

## 1. LLMの特性を理解する：設計の前提条件

アーキテクチャを選択する前に、まずLLMという「エンジン」の性質を正確に把握しましょう。人間の新入社員を管理するのと同様、相手の得意・不得意を理解することが適切な業務分担の出発点です。

### LLMが得意なこと：活用すべき強み

**パターン認識と推論**：大量のデータから複雑なパターンを見つけ出し、文脈に応じた柔軟な判断が可能
**自然言語理解**：曖昧で不完全な人間の指示も、意図を汲み取って適切に解釈  
**創発的問題解決**：予期していなかった状況でも、既存知識を組み合わせて新しい解決策を生成

### LLMが苦手なこと：設計で補完すべき弱点

**決定論的処理**：同じ入力でも出力が微妙に変わる確率的性質（数値計算や厳密なデータ操作は危険）
**長期記憶の保持**：対話が長くなると初期の文脈を忘れる（重要な情報は外部システムで管理必須）
**事実性の担保**：存在しない情報を自信満々に生成する「ハルシネーション」のリスク

この理解を踏まえて、まず対照的な2つの基本的なアプローチを比較してみましょう。以下の図は、制御重視と自律重視という設計思想を視覚的に示しています：

| **プレイブック駆動型（制御重視）** | **MCP対応型（自律重視）** |
|:---:|:---:|
| 👤 ユーザー入力 | 👤 ユーザー入力 |
| ↓ | ↓ |
| 🧠 **LLM**<br/>自然言語理解 | 🧠 **LLM**<br/>動的プランナー |
| ↓ | ↓ |
| ⚙️ **ステートマシン**<br/>事前定義フロー | 🔧 **ツール群**<br/>動的選択・組合せ |
| ↓ | ↓ |
| ✅ **決定論的処理** | 💡 **創発的問題解決** |
| ↓ | ↓ |
| 📊 **予測可能な結果** | 🎨 **柔軟な結果** |

## 2. プレイブック駆動型：LLMを搭載した「ステートマシン」

プレイブックを単なる「脚本」と捉えるのは表層的です。その本質は、**LLMを自然言語インターフェースとして組み込んだ、決定論的な「ステートマシン」です** 。

**アーキテクチャ思想**:
ビジネスプロセスは、検証可能で予測可能な状態遷移の連続としてモデル化されるべきです。LLMの役割は、ユーザーの曖昧な入力を解釈し、現在の状態から次に遷移すべき状態を特定することに限定されます。つまり、**プロセスの「WHAT（何をするか）」と「WHEN（いつするか）」は開発者が設計時に定義し** 、LLMはユーザーとの対話を通じてその遷移をトリガーする役割を担います。

**商用実装の代表例：Google Dialogflow CX**

このアーキテクチャの代表的な実装例が[**Google Dialogflow CX**](https://cloud.google.com/dialogflow/cx/docs)です。Dialogflow CXでは、会話の流れを以下の厳密な構造で管理します：

- **フロー（Flows）**: 大きなビジネスプロセス単位（例：注文処理、問い合わせ対応）
- **ページ（Pages）**: 各状態における具体的な処理とユーザー対話
- **ステートハンドラー（State Handlers）**: 状態遷移の条件とアクション

この構造により、対話システム全体が予測可能で監査可能となり、プレイブック＝ステートマシンという概念を実際のプロダクトレベルで証明しています。

**LLM特性の戦略的活用**:
このアーキテクチャは、LLMの強み（自然言語理解、文脈把握）を最大化しつつ、弱点（非決定性、ハルシネーション）を構造的に制約します。LLMは「ユーザーの曖昧な要求を理解し、事前定義された適切な状態に案内する優秀なナビゲーター」として機能します。

**開発とデバッグ**:
このモデルでは、ビジネスロジックはバージョン管理された「プロンプト（指示）」としてコードベースに組み込まれます。バグが発生した場合、開発者はエージェントの不透明な推論過程を追うのではなく、特定のプレイブックの指示を修正します。これは、従来のソフトウェアデバッグに近い、再現性の高いアプローチです。

## 3. MCP対応型：動的な「ツールエコシステム」

MCPを単なる「道具箱」と考えるのもまた、その本質を見落としています。MCP（Model Context Protocol）は、**エージェントと外部ツール間の標準化されたコミュニケーションプロトコル** です。

**アーキテクチャ思想**:
MCPが可能にするのは、LLMが定義されたプロトコルを通じて外部ツールと動的に連携することです。LLMは与えられた目標を達成するために、**利用可能なツールを動的に発見・選択・実行する「プランナー」** として機能します。開発者の役割は、MCP標準に準拠した信頼性の高いツールをエコシステムに提供することであり、**エージェントが「HOW（どうやるか）」を状況に応じて自律的に決定** できる環境を実現します。

**背景理論：ReActフレームワーク**

ツールを用いたLLMエージェントの基礎理論として、[**ReAct（Reason+Act）フレームワーク**](https://arxiv.org/abs/2210.03629)があります。これはアーキテクチャに依存しない汎用的な認知ループであり、以下のサイクルで構成されます：

1. **思考（Reason）**: 現状を分析し、次の行動を計画
2. **行動（Act）**: ツールを実行して外部情報を取得  
3. **観察（Observe）**: 結果を評価し、推論を更新

このサイクルにより、LLMは自身の推論を外部情報で「グラウンディング」し、信頼性を高められます。

**学習能力の実証：Toolformerの発見**

重要な発見として、Metaの[**Toolformer研究**](https://arxiv.org/abs/2302.04761)があります。この研究により、**LLMがツールの使い方を自己学習によって獲得できる**ことが証明されました。つまり、事前にプログラムされた手順に従うだけでなく、新しいツールに出会った際も、その説明文書から使用方法を理解し、適切にAPIを呼び出すことができるのです。

これにより、MCPアーキテクチャにおいてLLMが動的な「サービスオーケストレーター」として機能することの理論的根拠があります。

**LLM特性の戦略的活用**:
このアーキテクチャは、LLMの最大の強み（推論力、創発的問題解決、柔軟性）を積極的に活用します。一方で弱点（非決定性、ハルシネーション、長期記憶制約）は、動的な監視システムと外部ツールの適切な設計で補完します。LLMは「利用可能なツールを駆使して、複雑な問題を段階的に解決する優秀な戦略家」として機能します。

**先進的な概念**:
このパラダイムの最先端が[**アクティブ・ツール・ディスカバリー**](https://arxiv.org/abs/2506.01056)です。これは、エージェントが自身の能力ギャップを認識し、それを埋めるツールをオンデマンドで要求する仕組みです。

## 4. トレードオフの多角的分析：LLM特性から見た設計判断

前章で解説したLLMの特性理解を踏まえて、2つのアーキテクチャがどのような設計判断の結果なのかを比較しましょう。

| 比較軸 | プレイブック駆動型 | MCP対応型（ツール利用） |
|:---|:---|:---|
| **制御の所在** | **開発者**（設計時にプロセスを定義） | **LLM**（実行時にプロセスを構築） |
| **リスク管理戦略** | **事前防止**：厳格なガードレールで逸脱を防ぐ | **事後観測**：動的な監視と介入でリスクを管理 |
| **開発ライフサイクル** | **従来型開発**: 要件定義と実装が中心 | **エージェント開発**: 振る舞いの形成と目標設定が中心 |
| **デバッグアプローチ** | プロンプトと指示の直接的な修正 | 推論トレースの分析とFew-shot例の調整 |
| **コストモデル** | **トランザクションベース**（予測可能） | **計算量ベース**（変動しやすい） |
| **理想的な開発者像** | プロセス設計と構造化に長けたアーキテクト | 能力のカプセル化とエコシステム設計に長けたエンジニア |

## 5. 実践的設計パターン：LLM特性に基づく3つの思考モデル

あなたのタスクに最適なアーキテクチャを選択するための、3つの思考モデルを提示します。

### パターンA：プレイブック主導型 ― 制御重視アプローチ

**設計アプローチ**: 事前に定義された明確な状態遷移でビジネスプロセスをモデル化し、LLMはユーザー入力を適切な状態へ映射する役割を担います。

**適用領域**:
- **コンプライアンスが支配する領域**: 金融、法務、医療など、プロセスの逸脱が許されず、すべての対話が監査対象となる業務
- **タスクが完全に構造化されている領域**: Eコマースの注文プロセス、予約受付など、必要な情報と手順が固定されているタスク

**設計の核心**: いかにしてエッジケースを洗い出し、すべての分岐をプレイブックの指示として明示的に定義できるか。

### パターンB：MCP主導型 ― 「新入社員への権限委譲」モデル

**設計アプローチ**: LLMの推論能力を活用して目標達成のための最適な手順を動的に構築し、必要に応じて利用可能なツールを組み合わせます。

**適用領域**:
- **解法が未知の領域**: オープンエンドな調査、複雑なシステムのトラブルシューティング、科学的発見など、事前に手順を定義することが不可能なタスク
- **創造性が価値となる領域**: 複数の情報源を組み合わせたコンテンツ生成、新しいデザイン案のブレインストーミングなど

**設計の核心**: いかにして個々のツールを堅牢で信頼性が高く、かつLLMがその機能を誤解しないように（明確な説明を付与して）カプセル化できるか。

### パターンC：ハイブリッド型 ― 「指揮者と演奏者」モデル

**設計アプローチ**: ビジネスプロセスの全体構造と状態管理はプレイブックで制御し、具体的な作業の実行は専門化されたMCPツールに委任するアプローチです。

**適用領域**:
- **ほぼすべての現実的なエンタープライズアプリケーション**: これが最も汎用性が高く、堅牢なアーキテクチャとなることが多い
- **例**: サイバーセキュリティのインシデント対応。全体の対応フェーズ（検知→分析→封じ込め→根絶）はプレイブックで管理し、「特定のIPアドレスの脅威情報を分析する」といった具体的なアクションは専門のツールに委任する

**実装フレームワーク：LangGraph**

このハイブリッドモデルを実装するための最適なフレームワークが[**LangGraph**](https://langchain-ai.github.io/langgraph/)です。LangGraphでは以下の構造でエージェントを構築します：

- **グラフ構造（制御プレーン）**: ステートマシンとしてプロセス全体の流れと状態遷移を定義
- **ノード（実行単位）**: 各ノードで具体的なツール呼び出しを行い、状況に応じた自律的な判断を実行
- **条件付きルーティング**: プレイブックの指示に基づいて次の処理を動的に決定

この設計により、「プレイブックの信頼性」と「MCPの柔軟性」を両立できます。

**ハイブリッドアーキテクチャの処理フロー**

```
👤 ユーザー入力
    ↓
🗣️ 自然言語理解
    ↓
🎯 制御プレーン（LangGraph状態管理）
    ↓
🔄 条件付きルーティング（プレイブック指示）
    ↓
🔧 MCPツール群（並列実行）
⚙️ ツールA  ⚙️ ツールB  ⚙️ ツールC
    ↓
✨ 統合された結果
```

**アーキテクチャの特徴**：
- **制御プレーン**：プレイブックによる信頼性の高い状態管理
- **実行プレーン**：MCPツールによる柔軟な専門処理
- **統合基盤**：LangGraphによる両者の連携と状態管理

**設計の核心**: プロセス全体の「状態」を管理するプレイブックと、特定の「能力」を提供するステートレスなツールとの間の関心事をいかに綺麗に分離し、明確なインターフェースを定義できるか。

## 結論：アーキテクチャ選択の指針

プレイブック、MCP、ハイブリッドは対立する概念ではなく、エージェントの**制御と自律性のスペクトラム**上に位置する、状況に応じた選択肢です。

**アーキテクチャ選択の指針**：

- **プレイブック駆動型**: コンプライアンスが重要で、プロセスが完全に定義された領域に適用
- **MCP対応型**: 解決方法が未知で、創造性や柔軟性が価値となる領域に適用
- **ハイブリッド型**: 現実的なエンタープライズアプリケーションの多くに適用

重要なのは、LLMという強力だが特殊な「エンジン」の性質を正確に理解し、プロジェクトの要件に最適なアーキテクチャを選択することです。これは単なる技術的選択ではなく、ビジネスリスクと開発効率を両立させる戦略的判断となります。

**将来展望**: これらのアプローチは、エージェントが自律的にツールを発見・要求する次世代技術への進化を支える土台です。


## 参考リソース

本記事の洞察を深めるために、以下の公式情報源を参考にしてください：

**プレイブックの概念と実装**
- [Google Dialogflow CX ドキュメント](https://cloud.google.com/dialogflow/cx/docs)：プレイブックを状態機械として捉える、最も洗練された公式リファレンス
- [Dialogflow CX Playbooks](https://cloud.google.com/dialogflow/cx/docs/concept/playbook)：プレイブックの具体的な実装方法

**エージェントの基本理論**  
- [ReAct: Synergizing Reasoning and Acting in Language Models](https://arxiv.org/abs/2210.03629)：エージェントの思考と行動のループを理解するための基礎論文
- [Toolformer: Language Models Can Teach Themselves to Use Tools](https://arxiv.org/abs/2302.04761)：LLMがツールの使い方を自己学習できることを実証した重要研究

**MCPと自律性**
- [Model Context Protocol (MCP) 公式仕様](https://spec.modelcontextprotocol.io/)：Anthropic公式のMCP仕様書
- [MCP Python SDK](https://github.com/modelcontextprotocol/python-sdk)：MCP実装のための公式Python SDK
- [MCP-Zero: Active Tool Discovery for Autonomous LLM Agents](https://arxiv.org/abs/2506.01056)：アクティブ・ツール・ディスカバリーの理論と実装

**実践的な設計思想とフレームワーク**
- [LangGraph 公式ドキュメント](https://langchain-ai.github.io/langgraph/)：ハイブリッドモデルを実装するための公式ガイド
- [LangGraph GitHub リポジトリ](https://github.com/langchain-ai/langgraph)：実装例とコードサンプル

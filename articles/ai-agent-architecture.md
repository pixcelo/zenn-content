---
title: "AIエージェント設計：制御重視vs自律重視アーキテクチャの選択指針"
emoji: "🤖"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["ai", "architecture", "mcp", "aiエージェント", "llm"]
published: false
---

新人エンジニアにタスクを任せるとき、詳細な手順書を渡しますか？それとも目標だけ伝えて任せますか？経験豊富な開発者なら、この判断が後のプロジェクト成否を左右することを知っています。

AIエージェントでも、まったく同じ判断が求められています。エージェントに**厳格な手順を守らせるか**、それとも**目標達成の方法を自由に考えさせるか**——この設計選択が、システムの信頼性、開発効率、そして事業リスクを決定します。

現在、この課題に対して2つの主要なアーキテクチャアプローチが競合しています：

- **プレイブック駆動型**：確実な手順を事前定義し、エージェントはその案内役に徹する「**制御重視**」
- **[MCP（Model Context Protocol）](https://spec.modelcontextprotocol.io/)対応型**：エージェント自身に判断を委ね、状況に応じて最適解を模索させる「**自律重視**」

本記事では、この2つのアプローチを技術的な観点だけでなく、ビジネスリスク・開発コスト・保守性まで含めて徹底比較します。あなたのプロジェクトに最適な選択を支援する、実践的な判断基準を提供します。

## 1. LLMの特性を理解する：設計の前提条件

アーキテクチャを選択する前に、まずLLMという「エンジン」の性質を正確に把握しましょう。人間の新入社員を管理するのと同様、相手の得意・不得意を理解することが適切な業務分担の出発点です。

### LLMが得意なこと：活用すべき強み

**パターン認識と推論**：大量のデータから複雑なパターンを見つけ出し、文脈に応じた柔軟な判断が可能
**自然言語理解**：曖昧で不完全な人間の指示も、意図を汲み取って適切に解釈  
**創発的問題解決**：予期していなかった状況でも、既存知識を組み合わせて新しい解決策を生成

### LLMが苦手なこと：設計で補完すべき弱点

**決定論的処理**：同じ入力でも出力が微妙に変わる確率的性質（数値計算や厳密なデータ操作は危険）
**長期記憶の保持**：対話が長くなると初期の文脈を忘れる（重要な情報は外部システムで管理必須）
**事実性の担保**：存在しない情報を自信満々に生成する「ハルシネーション」のリスク

この理解を踏まえて、2つの主要なアーキテクチャアプローチを見てみましょう。

| **プレイブック駆動型（制御重視）** | **MCP対応型（自律重視）** |
|:---:|:---:|
| 👤 ユーザー入力 | 👤 ユーザー入力 |
| ↓ | ↓ |
| 🧠 **LLM**<br/>自然言語理解 | 🧠 **LLM**<br/>動的プランナー |
| ↓ | ↓ |
| ⚙️ **ステートマシン**<br/>事前定義フロー | 🔧 **ツール群**<br/>動的選択・組合せ |
| ↓ | ↓ |
| ✅ **決定論的処理** | 💡 **創発的問題解決** |
| ↓ | ↓ |
| 📊 **予測可能な結果** | 🎨 **柔軟な結果** |

## 2. プレイブック駆動型：LLMを搭載した「ステートマシン」

プレイブックを単なる「脚本」と捉えるのは表層的です。その本質は、**LLMを自然言語インターフェースとして組み込んだ、決定論的な「ステートマシン（状態機械）」です** 。

**アーキテクチャ思想**:
ビジネスプロセスは、検証可能で予測可能な状態遷移の連続としてモデル化されるべきです。LLMの役割は、ユーザーの曖昧な入力を解釈し、現在の状態から次に遷移すべき状態を特定することに限定されます。つまり、**プロセスの「WHAT（何をするか）」と「WHEN（いつするか）」は開発者が設計時に定義し** 、LLMはユーザーとの対話を通じてその遷移をトリガーする役割を担います。

**商用実装の代表例：Google Dialogflow CX**

このアーキテクチャの代表的な実装例が[**Google Dialogflow CX**](https://cloud.google.com/dialogflow/cx/docs)です。Dialogflow CXでは、会話の流れを以下の厳密な構造で管理します：

- **フロー（Flows）**: 大きなビジネスプロセス単位（例：注文処理、問い合わせ対応）
- **ページ（Pages）**: 各状態における具体的な処理とユーザー対話
- **ステートハンドラー（State Handlers）**: 状態遷移の条件とアクション

この構造により、対話システム全体が予測可能で監査可能となり、プレイブック＝ステートマシンという概念を実際のプロダクトレベルで証明しています。

**LLM特性の戦略的活用**:
このアーキテクチャは、LLMの強み（自然言語理解、文脈把握）を最大化しつつ、弱点（非決定性、ハルシネーション）を構造的に制約します。LLMは「ユーザーの曖昧な要求を理解し、事前定義された適切な状態に案内する優秀なナビゲーター」として機能します。

**開発とデバッグ**:
このモデルでは、ビジネスロジックはバージョン管理された「プロンプト（指示）」としてコードベースに組み込まれます。バグが発生した場合、開発者はエージェントの不透明な推論過程を追うのではなく、特定のプレイブックの指示を修正します。これは、従来のソフトウェアデバッグに近い、再現性の高いアプローチです。

## 3. MCP対応型：自己組織化する「マイクロサービス群」

MCPを単なる「道具箱」と考えるのもまた、その本質を見落としています。これは、**エージェント自身が動的なサービスディスカバリーとオーケストレーションを行う、「能力指向アーキテクチャ」です** 。

**アーキテクチャ思想**:
LLMは単なるツール利用者ではなく、与えられた目標を達成するための**動的な「プランナー」です** 。開発者の役割は、個々の能力をカプセル化した信頼性の高い「ツール（マイクロサービス）」をエコシステムに提供することにあります。エージェントは、**プロセスの「HOW（どうやるか）」を状況に応じて自ら構築します** 。これは、ビルド時に静的にライブラリをリンクするのではなく、実行時に動的に必要なサービスを発見し連携するマイクロサービスアーキテクチャの思想と共通しています。

**理論的基盤：ReActフレームワーク**

LLMが自律的に行動できる理論的根拠が[**ReAct（Reason+Act）フレームワーク**](https://arxiv.org/abs/2210.03629)です。これは以下の認知ループを通じて、エージェントが動的に計画を修正する仕組みです：

1. **思考（Reason）**: 現状を分析し、次の行動を計画
2. **行動（Act）**: ツールを実行して外部情報を取得  
3. **観察（Observe）**: 結果を評価し、推論を更新

このサイクルにより、LLMは自身の推論を外部情報で「グラウンディング」し、信頼性を高められます。

**学習能力の実証：Toolformerの発見**

重要な発見として、Metaの[**Toolformer研究**](https://arxiv.org/abs/2302.04761)があります。この研究により、**LLMがツールの使い方を自己学習によって獲得できる**ことが証明されました。つまり、事前にプログラムされた手順に従うだけでなく、新しいツールに出会った際も、その説明文書から使用方法を理解し、適切にAPIを呼び出すことができるのです。

これにより、MCPアーキテクチャにおいてLLMが動的な「サービスオーケストレーター」として機能することの理論的根拠があります。

**LLM特性の戦略的活用**:
このアーキテクチャは、LLMの最大の強み（推論力、創発的問題解決、柔軟性）を積極的に活用します。一方で弱点（非決定性、ハルシネーション、長期記憶制約）は、動的な監視システムと外部ツールの適切な設計で補完します。LLMは「利用可能なツールを駆使して、複雑な問題を段階的に解決する優秀な戦略家」として機能します。

**先進的な概念**:
このパラダイムの最先端が[**アクティブ・ツール・ディスカバリー**](https://arxiv.org/abs/2506.01056)です。これは、エージェントが自身の能力ギャップを認識し、それを埋めるツールをオンデマンドで要求する仕組みです。従来の「事前定義されたツールから選択する受動的セレクター」から、「必要に応じてツールを発見・要求する自律的エージェント」への進化を実現します。

## 4. トレードオフの多角的分析：LLM特性から見た設計判断

前章で解説したLLMの特性理解を踏まえて、2つのアーキテクチャがどのような設計判断の結果なのかを比較しましょう。

| 比較軸 | プレイブック駆動型 | MCP対応型（ツール利用） |
|:---|:---|:---|
| **制御の所在** | **開発者**（設計時にプロセスを定義） | **LLM**（実行時にプロセスを構築） |
| **リスク管理戦略** | **事前防止**：厳格なガードレールで逸脱を防ぐ | **事後観測**：動的な監視と介入でリスクを管理 |
| **開発ライフサイクル** | **SDLC** (Software Development Life Cycle): 要件定義と実装が中心 | **ADLC** (Agent Development Life Cycle): 振る舞いの形成と目標設定が中心 |
| **デバッグアプローチ** | プロンプトと指示の直接的な修正 | 推論トレースの分析とFew-shot例の調整 |
| **コストモデル** | **トランザクションベース**（予測可能） | **計算量ベース**（変動しやすい） |
| **理想的な開発者像** | プロセス設計と構造化に長けたアーキテクト | 能力のカプセル化とエコシステム設計に長けたエンジニア |

## 5. 実践的設計パターン：LLM特性に基づく3つの思考モデル

あなたのタスクに最適なアーキテクチャを選択するための、3つの思考モデルを提示します。

### パターンA：プレイブック主導型 ― 「超高性能IVR」モデル

**思考モデル**: 「自然言語を完璧に理解する、インタラクティブな音声応答（IVR）システムや業務フローを構築している」と考える。ユーザーは自由に話すが、システムは必ず定義されたフローに沿って応答を返す。

**適用領域**:
- **コンプライアンスが支配する領域**: 金融、法務、医療など、プロセスの逸脱が許されず、すべての対話が監査対象となる業務
- **タスクが完全に構造化されている領域**: Eコマースの注文プロセス、予約受付など、必要な情報と手順が固定されているタスク

**設計の核心**: いかにしてエッジケースを洗い出し、すべての分岐をプレイブックの指示として明示的に定義できるか。

### パターンB：MCP主導型 ― 「新入社員への権限委譲」モデル

**思考モデル**: 「非常に優秀だが経験の浅い新入社員に、目標といくつかの社内システム（ツール）へのアクセス権を与えて、仕事を任せる」と考える。マイクロマネジメントはせず、結果を信頼するが、定期的な進捗確認（監視）は欠かせない。

**適用領域**:
- **解法が未知の領域**: オープンエンドな調査、複雑なシステムのトラブルシューティング、科学的発見など、事前に手順を定義することが不可能なタスク
- **創造性が価値となる領域**: 複数の情報源を組み合わせたコンテンツ生成、新しいデザイン案のブレインストーミングなど

**設計の核心**: いかにして個々のツールを堅牢で信頼性が高く、かつLLMがその機能を誤解しないように（明確な説明を付与して）カプセル化できるか。

### パターンC：ハイブリッド型 ― 「指揮者と演奏者」モデル

**思考モデル**: 「自分はオーケストラの指揮者（プレイブック）として、曲全体の構成（ビジネスプロセス）と各パートの演奏開始のタイミングを指示する。しかし、個々の楽器の具体的な演奏技術（ツールの内部ロジック）は、専門の演奏者（MCPツール）に完全に委ねる」と考える。

**適用領域**:
- **ほぼすべての現実的なエンタープライズアプリケーション**: これが最も汎用性が高く、堅牢なアーキテクチャとなることが多い
- **例**: サイバーセキュリティのインシデント対応。全体の対応フェーズ（検知→分析→封じ込め→根絶）はプレイブックで管理し、「特定のIPアドレスの脅威情報を分析する」といった具体的なアクションは専門のツールに委任する

**実装フレームワーク：LangGraph**

このハイブリッドモデルを実装するための最適なフレームワークが[**LangGraph**](https://langchain-ai.github.io/langgraph/)です。LangGraphでは以下の構造でエージェントを構築します：

- **グラフ構造（制御プレーン）**: ステートマシンとしてプロセス全体の流れと状態遷移を定義
- **ノード（実行単位）**: 各ノードで具体的なツール呼び出しを行い、状況に応じた自律的な判断を実行
- **条件付きルーティング**: プレイブックの指示に基づいて次の処理を動的に決定

この設計により、「プレイブックの信頼性」と「MCPの柔軟性」を両立できます。

**ハイブリッドアーキテクチャの処理フロー**

```
👤 ユーザー入力
    ↓
🗣️ 自然言語理解
    ↓
🎯 制御プレーン（LangGraph状態管理）
    ↓
🔄 条件付きルーティング（プレイブック指示）
    ↓
🔧 MCPツール群（並列実行）
⚙️ ツールA  ⚙️ ツールB  ⚙️ ツールC
    ↓
✨ 統合された結果
```

**アーキテクチャの特徴**：
- **制御プレーン**：プレイブックによる信頼性の高い状態管理
- **実行プレーン**：MCPツールによる柔軟な専門処理
- **統合基盤**：LangGraphによる両者のシームレスな連携

**設計の核心**: プロセス全体の「状態」を管理するプレイブックと、特定の「能力」を提供するステートレスなツールとの間の関心事をいかに綺麗に分離し、明確なインターフェースを定義できるか。

## 結論：ハイブリッドアーキテクチャが最適解である

プレイブックとMCPは対立する概念ではなく、エージェントの**制御と自律性のスペクトラム**上に位置する、補完的な設計要素です。

**ハイブリッドアーキテクチャこそが現代の解**

本記事の分析を通じて明らかになったのは、単一のパラダイムでは現実の複雑性に対応できないということです。**「プレイブックの信頼性」と「MCPの柔軟性」を統合したハイブリッドアーキテクチャが、現代のエンタープライズAIエージェント開発における堅牢なソリューション** です。

このアプローチでは：
- **プレイブック（制御プレーン）**: ビジネスプロセスの骨格と状態管理を担保
- **MCPツール（実行プレーン）**: 具体的な能力と動的な問題解決を提供
- **LangGraph（実装基盤）**: 両者を統合する技術的な架け橋を実現

## 次なるフロンティア：アクティブ・ツール・ディスカバリー

そしてその先には、さらなる進化が待っています。エージェントが事前に与えられたツールを使うだけでなく、**自身の能力ギャップを認識し、必要なツールを動的に要求・発見する「アクティブ・ツール・ディスカバリー」の時代** が到来しようとしています。

これは、エージェントが受動的なツール選択者から、能動的な**「ケイパビリティアーキテクト」へと進化** することを意味します。この未来では、エージェントは自律的に新しい能力を組み合わせ、創造的な問題解決を実現します。

**コンポーザブルな未来へ**

今、私たちが設計する一つ一つのエージェントは、このエコシステムを構成する未来の部品です。ハイブリッドアーキテクチャを基盤とし、段階的にアクティブ・ツール・ディスカバリーへと進化していく――これが、AIエージェント設計における戦略的ロードマップなのです。

## まとめ：LLM特性を理解した設計選択を

本記事では、AIエージェント設計の核心が「LLMの特性理解に基づく適材適所の活用」にあることを解説しました。

**プレイブック駆動型** は、LLMの弱点を制約で封じ込みながら強みを活用する「制御重視」のアプローチです。**MCP対応型** は、LLMの推論力を最大化しつつ弱点を動的監視で補完する「自律重視」のアプローチです。そして **ハイブリッド型** が、両者の利点を統合した最適解として位置づけられます。

重要なのは、LLMという強力だが特殊な「エンジン」の性質を正確に理解し、あなたのプロジェクトの要件に最適なアーキテクチャを選択することです。単なる技術的選択ではなく、ビジネスリスクと開発効率を両立させる戦略的判断として捉えることが、成功するAIエージェント開発への第一歩です。

## 参考リソース

本記事の洞察を深めるために、以下の公式情報源を参考にしてください：

**プレイブックの概念と実装**
- [Google Dialogflow CX ドキュメント](https://cloud.google.com/dialogflow/cx/docs)：プレイブックを状態機械として捉える、最も洗練された公式リファレンス
- [Dialogflow CX Playbooks](https://cloud.google.com/dialogflow/cx/docs/concept/playbook)：プレイブックの具体的な実装方法

**エージェントの基本理論**  
- [ReAct: Synergizing Reasoning and Acting in Language Models](https://arxiv.org/abs/2210.03629)：エージェントの思考と行動のループを理解するための基礎論文
- [Toolformer: Language Models Can Teach Themselves to Use Tools](https://arxiv.org/abs/2302.04761)：LLMがツールの使い方を自己学習できることを実証した重要研究

**MCPと自律性**
- [Model Context Protocol (MCP) 公式仕様](https://spec.modelcontextprotocol.io/)：Anthropic公式のMCP仕様書
- [MCP Python SDK](https://github.com/modelcontextprotocol/python-sdk)：MCP実装のための公式Python SDK
- [MCP-Zero: Active Tool Discovery for Autonomous LLM Agents](https://arxiv.org/abs/2506.01056)：アクティブ・ツール・ディスカバリーの理論と実装

**実践的な設計思想とフレームワーク**
- [LangGraph 公式ドキュメント](https://langchain-ai.github.io/langgraph/)：ハイブリッドモデルを実装するための公式ガイド
- [LangGraph GitHub リポジトリ](https://github.com/langchain-ai/langgraph)：実装例とコードサンプル

**ビジネス観点での戦略ガイド**
- [a16z "AI Agent Infrastructure"](https://a16z.com/ai-agent-infrastructure/)：エージェント開発をビジネス視点で捉えた戦略的ガイド
